#!/usr/bin/env bash
#
# SPDX-License-Identifier: MPL-2.0
# SPDX-FileCopyrightText: 2025 Tony Germano and Mitch Gaffigan
#

# =============================================================================
# Open Integration Engine Server Launcher Script
#
# Description:
#   This script is the main launcher for the Open Integration Engine (OIE)
#   server. It prepares the Java environment and executes the server launcher
#   JAR file.
#
#   The script automatically finds a compatible Java runtime (version 17+ by
#   default) by searching for a valid executable in the following priority order:
#     1. The OIE_JAVA_PATH environment variable.
#     2. The -java-cmd directive in the oieserver.vmoptions file or included
#        .vmoptions files. Must specify the path to the 'java' executable.
#        This is the preferred way to declare the desired version for running
#        the server and can be overridden by OIE_JAVA_PATH. Can be a relative
#        path from the location of this script.
#     3. The JAVA_HOME environment variable.
#     4. The 'java' command available in the system's PATH.
#
#   It also parses the 'oieserver.vmoptions' file to configure JVM options,
#   system properties (-D...), and classpath modifications.
#
# Usage:
#   ./oieserver.sh [app-arguments]
#
#   All [app-arguments] are passed directly to the underlying Java application
#   (com.mirth.connect.server.launcher.MirthLauncher).
#
# Configuration via Environment Variables:
#   OIE_JAVA_PATH   - (Highest priority) Set the full path to the 'java'
#                   executable to be used. Can be a relative path from the
#                   location of this script or a tilde path
#                   (e.g., ~/path/to/java).
#   JAVA_HOME       - Set the path to the root of a Java installation. The
#                   script will look for 'bin/java' within this path.
# =============================================================================

APP_ARGS=("$@")
MIN_JAVA_VERSION=17

# Set OIE_HOME to the script directory
OIE_HOME="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
CLASSPATH="$OIE_HOME/mirth-server-launcher.jar"
VMOPTIONS=()
# This will hold the validated path to the Java executable. It is intentionally left empty for now.
FINAL_JAVA_CMD=""
# This will temporarily hold the result from parsing the vmoptions file.
VMOPTIONS_JAVA_CMD=""


# --- Function to resolve a path to a canonical absolute path ---
# Resolves a given path, handling tilde, relative, and '..' components.
# @param $1: The path to resolve.
# @echo: The resolved, canonical absolute path.
resolve_absolute_path() {
    local path_to_resolve="$1"

    # Explicitly handle tilde expansion first
    if [[ "$path_to_resolve" =~ ^~ ]]; then
        # Use eval to expand the tilde to the user's home directory.
        # This correctly handles "~", "~/path", and "~username/path".
        path_to_resolve=$(eval echo "$path_to_resolve")
    fi

    # If the path is not absolute, assume it's relative to OIE_HOME
    if [[ ! "$path_to_resolve" =~ ^/ ]]; then
        path_to_resolve="$OIE_HOME/$path_to_resolve"
    fi

    # Use cd and pwd to resolve '..' and '.' components for a canonical path.
    if [[ -d "$(dirname "$path_to_resolve")" ]]; then
        echo "$(cd "$(dirname "$path_to_resolve")" && pwd)/$(basename "$path_to_resolve")"
    else
        # If the directory doesn't exist, we can't resolve '..'. Return the concatenated path.
        # Subsequent checks in is_valid_java_version will then fail it gracefully.
        echo "$path_to_resolve"
    fi
}

# --- Function to validate Java version ---
# Checks if a given command points to a Java executable of the required minimum version.
# @param $1: The java command or path to check (e.g., "java", "/opt/jdk-17/bin/java")
# @return: 0 on success (is valid), 1 on failure.
is_valid_java_version() {
    local java_cmd="$1"
    local error_message="Warning: '$java_cmd' is specified by $2, which is not a valid Java executable of at least version $MIN_JAVA_VERSION. Ignoring."

    # Check if the command is found and is executable
    if ! command -v "$java_cmd" &> /dev/null || ! [[ -x "$(command -v "$java_cmd")" ]]; then
        echo "$error_message" >&2
        return 1
    fi

    # Execute 'java -version' and capture the output from stderr
    # Example output: openjdk version "17.0.2" 2022-07-19
    local version_output
    version_output=$("$java_cmd" -version 2>&1)

    # Check if the version command succeeded
    if [[ $? -ne 0 ]]; then
        echo "$error_message" >&2
        return 1
    fi

    # Extract the major version number. This works for formats like "1.8.0" and "17.0.2".
    local major_version
    major_version=$(echo "$version_output" | head -n 1 | cut -d '"' -f 2 | cut -d '.' -f 1)

    # Check if the extracted version is a number and meets the minimum requirement
    if [[ "$major_version" =~ ^[0-9]+$ ]] && [[ "$major_version" -ge "$MIN_JAVA_VERSION" ]]; then
        echo "Info: Found suitable java version specified by $2"
        return 0 # Success
    else
        echo "$error_message" >&2
        return 1 # Failure
    fi
}

# Set Java options by parsing the vmoptions file
parse_vmoptions() {
    local file="$1"

    if [[ ! -f "$file" ]]; then
        echo "Warning: VM options file not found: $file" >&2
        return 1
    fi

    # Read the file line by line
    while IFS= read -r line; do
        # Trim leading/trailing whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # Skip empty lines and comments
        if [[ -z "$line" || "$line" =~ ^# ]]; then
            continue
        fi

        # Evaluate environment variables to be their actual values
        # NOTE: This eval also handles tilde expansion for vmoptions lines.
        line=$(eval echo "$line")
        
        # Check for -include-options directive
        if [[ "$line" =~ ^-include-options[[:space:]]+(.+) ]]; then
            local included_file="${BASH_REMATCH[1]}"
            # Resolve relative paths
            if [[ ! "$included_file" =~ ^/ ]]; then # Not an absolute path
                included_file="$(dirname "$file")/$included_file"
            fi
            # Recursively call parse_vmoptions for the included file
            parse_vmoptions "$included_file"
        elif [[ "$line" =~ ^-classpath[[:space:]]+(.+) ]]; then
            # Handle -classpath directive
            CLASSPATH="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^-classpath/a[[:space:]]+(.+) ]]; then
            # Handle -classpath/a directive (append to existing classpath)
            CLASSPATH="${CLASSPATH}:${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^-classpath/p[[:space:]]+(.+) ]]; then
            # Handle -classpath/p directive (prepend to existing classpath)
            CLASSPATH="${BASH_REMATCH[1]}:${CLASSPATH}"
        elif [[ "$line" =~ ^-java-cmd[[:space:]]+(.+) ]]; then
            # Handle -java-cmd directive
            local candidate_java_cmd="${BASH_REMATCH[1]}"
            # Resolve path to an absolute one before validation
            local resolved_candidate_cmd
            resolved_candidate_cmd=$(resolve_absolute_path "$candidate_java_cmd")
            
            if [[ -z "$FINAL_JAVA_CMD" ]] && is_valid_java_version "$resolved_candidate_cmd" "the -java-cmd directive in '$file'"; then
                VMOPTIONS_JAVA_CMD="$resolved_candidate_cmd"
            fi
        else
            # Add the option to the accumulated string
            VMOPTIONS+=("$line")
        fi
    done < "$file"
    return 0
}

# The OIE_JAVA_PATH has highest priority for specifying the Java executable.
# If a valid version is found, the '-java-cmd' directive will be ignored when parsing the VM options file.
if [[ -n "$OIE_JAVA_PATH" ]]; then
    # Resolve path to an absolute one before validation
    resolved_oie_java_path=$(resolve_absolute_path "$OIE_JAVA_PATH")

    if is_valid_java_version "$resolved_oie_java_path" "the OIE_JAVA_PATH environment variable"; then
        FINAL_JAVA_CMD="$resolved_oie_java_path"
    fi
fi

# Recursively parse the VM options file
parse_vmoptions "$OIE_HOME/oieserver.vmoptions"

# Find the Java executable if not already set by '$OIE_JAVA_PATH'
if [[ -z "$FINAL_JAVA_CMD" ]]; then
    # Check for the result from parsing the vmoptions file.
    # Validation is done during parsing.
    if [[ -n "$VMOPTIONS_JAVA_CMD" ]]; then
        FINAL_JAVA_CMD="$VMOPTIONS_JAVA_CMD"
    # If not found, check JAVA_HOME
    elif [[ -n "$JAVA_HOME" ]] && [[ -f "$JAVA_HOME/bin/java" ]] && is_valid_java_version "$JAVA_HOME/bin/java" "the JAVA_HOME environment variable"; then
        FINAL_JAVA_CMD="$JAVA_HOME/bin/java"
    # If still not found, check for 'java' in the system PATH
    elif is_valid_java_version "java" "the system PATH"; then
        FINAL_JAVA_CMD="java"
    fi
fi

# Final check for a valid Java path before execution.
if [[ -z "$FINAL_JAVA_CMD" ]]; then
    echo "Error: Could not find a Java ${MIN_JAVA_VERSION}+ installation." >&2
    echo "Please configure -java-cmd in conf/custom.vmoptions, set JAVA_HOME, set OIE_JAVA_PATH, or ensure 'java' in your PATH is version ${MIN_JAVA_VERSION} or higher." >&2
    exit 1
fi

JAVA_OPTS=("${VMOPTIONS[@]}" 
           "-cp" "$CLASSPATH" 
           "com.mirth.connect.server.launcher.MirthLauncher" 
           "${APP_ARGS[@]}")

# Launch Open Integration Engine (as this PID with exec)
echo "Starting Open Integration Engine..."
echo "Using Java from: $FINAL_JAVA_CMD"
echo "$FINAL_JAVA_CMD ${JAVA_OPTS[*]}"
exec "$FINAL_JAVA_CMD" "${JAVA_OPTS[@]}"
